# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Назарова А.И.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |     4        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В результате выполнения этого курсового проекта я получу практические знания о языке ProLog, научусь строить родословное дерево, что кстати полезно, ведь именно благодаря ему можно узнать, как много у тебя родственников, а также овладею минимальными знаниями о языке Python.

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: parents(потомок, отец, мать).
 3. Реализовать предикат проверки/поиска шурина.
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Свое родословное дерево я построила на сайте MyHeritage.com, после чего экспортировала его в формате GEDCOM. В моем родословном дереве 33 индивидуума.

## Конвертация родословного дерева

Для решения данной задачи я решила использовать язык Python.До этого момента я с ним не сталкивалась, но решила писать именно на нем, потому что и преподаватель, и одногруппники посоветовали его.
Программа открывает файл,считывает его построчно и находит нужные данные.
Файл считывает INDI(проще говоря id) каждого человека, добавляет его в словарь, после чего благодаря последним данным из файла, который мы получаем на входе, определяются отношения родства (HUSB-WIFE-CHIL), после чего выводим на экран предикат parent(потомок, отец, мать).


```python
file = open( "familytree.ged", "r")
inform = file.readlines()
file.close()

person = {}
ID = ""
name = ""

for line in inform:
    if(line.find('INDI', 0, len(line)-1)!=-1):
        word = line.split(' ')
        ID = word[1]
    elif ((line.find('GIVN',0,len(line)-1)!=-1)):
        word = line.split(' ')
        name = word[2].rstrip()
    elif ((line.find('SURN', 0, len(line) - 1) != -1)):
        word = line.split(' ')
        name = name + ' ' + word[2].rstrip()
        person[ID]= name

parents = []
husb = ""
wife = ""

for line in inform:
    if(line.find('HUSB', 0, len(line)-1)!=-1):
        word = line.split(' ')
        husb = person[word[2].rstrip()]
    elif(line.find('WIFE', 0, len(line)-1)!=-1):
        word = line.split(' ')
        wife = person[word[2].rstrip()]
    elif(line.find('CHIL', 0, len(line)-1)!=-1):
        word = line.split(' ')
        parents.append([person[word[2].rstrip()], husb,wife])


outfile = open("result.pl", "w")

for i in parents:
    outfile.write("parents('" + i[0] + "','" + i[1] + "','" + i[2] + "').\n")
outfile.close()

```
## Предикат поиска родственника

Мне в задании необходимо было найти шурина - это брат жены.

Создается список doughters, в который я поместила всех дочерей. Затем опрделеятеся предикат брат, жена. После чего осуществялем поиск, ищем тех женщин,у которых есть родные братья. 

```prolog

doughter(['Anastasiia Nazarova','Svetlana Nazarova','Oksana Nazarova','Nadezhda Filatova','Zinaida Chivileva','Valentina Chivileva',
'Ludmila Safonova','Victorya Tkacheva','Natalya Tokareva']).

find([First|_], First).
find([_|End_list], First):- find(End_list, First).

wife(W, M) :- 
    parents(_, M, W).

brother(X,Y):-
    parents(X,M,W), 
    parents(Y,M,W),
    X\=Y, 
    doughter(Doughter_list),
    not(find(Doughter_list, Y)).

shurin(S,M) :-
    wife(W,M),
    brother(W,S).


```

Реузльтат работы 

```prolog
?- shurin('Ivan Chivilev','Vladimir Filatov').
true.

?- shurin(X,'Vladimir Filatov').               
X = 'Nikolay Chivilev' ;
X = 'Alexander Chivilev' ;
X = 'Alexey Chivilev' ;
X = 'Ivan Chivilev' ;
X = 'Anatoly Chivilev' ;
X = 'Victor Chivilev'.
```
## Определение степени родства

Используем поиск в ширину для того, чтобы найти кратчайшее отношение родства. Реализуем предикаты check_link, для определения прямых отношений между двумя людьми. Прямые - то есть люди связаны на прямую, а не через какого-то человека. В итоге есть проверка отношений муж, жена, брат или сестра, отец, мать, ребенок, родитель. Я не использовала правила для получения дальнего родства, чтобы при поиске цепочек связи между людьми, она не "перескакивала" через родственников, которые связаны на прямую. Далее находится цепочка родственников, по которой и связаны эти люди, затем эту цепочку переводим в цепочку родства и получается ответ.

Результат работы программы 

```prolog
?- relative('Alexander Tkachev', 'Svetlana Nazarova',X).
X = [child, subling, father].

?- relative('Anastasiia Nazarova','Nadezhda Filatova',Res).
Res = [child].

```

## Естественно-языковый интерфейс

Обрабатываем запросы, выполненые на естественном языке и на основе запроса проверяем истинность высказывания или находим родственников. Запоминается последнее имя, на которое производился запрос, с помощью предиката nb_getval. Сначала проверяем корректность построения вопроса. Затем, в зависимости от постановки вопроса, ищем ответ. При анализе предложения также проверяем корректность построения и разбираем его по частям, оборачивая части вопроса в соответсвущие структуры.

Приведу пример одного из правил для предиката ask_question, все остальные построены аналогичным образом. Это правило находит ответ на вопрос, сколько определенных родственников имеет какой-то человек. Сначала мы проверяем корректность входных данных с помощью предикатов question_word, quantity, purals, help_word, have_has, question_mark. Также запоминаем, относительно имени какого человека задается вопрос, с помощью встроенного предиката nb_setval. Это потребуется в дальнейшем для обработки запросов с местоимениями. Приводим множественное число к единственному в предикате pural. ask_relative ищет всех запрашиваемых родственников заданного человека, а setof создает список из найденных уникальных имен. Далее получаем длину этого списка и печатаем результат в нужном порядке.

``` prolog
ask_question(List):-
    List = [A,B,C,D,E,F,H],
    question_word(A),
    quantity(B),
    purals(C),
    help_word(D),
    nb_setval(lastName,E),
    have_has(F),
    question_mark(H),

    pural(C1,C),
    setof(X,ask_relative(X,E,C1),T),
    length(T,Res),!,
    write(E),
    write(" has "),
    ((Res =:= 1,write(Res),write(" "),write( C1));(\+(Res =:= 1),write(Res),write(" "),write( C))),!.

```
Результаты работы программы 

```prolog
?- ask_question([who,is,'Vladimir Filatov', "'s",wife,?]). 
Valentina Chivileva is Vladimir Filatov's wife
true.

?- ask_question([how,many,sublings,does,'Victorya Tkacheva',have,?]). 
Victorya Tkacheva has 2 sublings
true.

```

## Выводы

Мною были получены не только навыки работы на языке Prolog. Помимо прочего, я узнала, как строятся генеалогические деревья, как хранятся в файле и как обрабатываются. Также стоит отметить, что в процессе написания эссе я смогла поближе познакомиться с Прологом, лучше узнать историю его создания и развития, его особенности, понять его место среди других языков программирования. Так, я узнала, что логическое программирование не основано на машине фон Неймана, на основе которой создаются практические все современнные компьютеры. Так же я узнала, что основной особенностью логическоего программирования является то, что мы не объясняем компьютеру, как и что делать. Мы даем лишь некоторый набор информации и на основе этого компьютер сам должен решить, что с этой информацией делать.

Данный курс дался мне непросто. К сожалению, по логическому программированию не так много информации, как, скажем, по объектно-ориентированному. Так же данная парадигма сильно отличается от тех, к которым мы привыкли, а, как известно, переучиваться всегда очень сложно. С другой стороны, мы рассмотрели реальную задачу, с решением которой вряд ли можно справиться лучше, если не прибегать к логическому программированию. Таким образом, мы получили новый опыт и новый впечатления, узнали о кардинально иных идеях, нежели тех, о которых мы слышали до этого.
